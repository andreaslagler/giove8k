/*
Copyright (C) 2021 Andreas Lagler

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.
*/

////////////////////////////////////////////////////////////////////////////////
// Configuration bits (automatically generated by MPLAB)
////////////////////////////////////////////////////////////////////////////////

// FICD
#pragma config ICS = PGD1               // ICD Communication Channel Select bits (Communicate on PGEC1 and PGED1)
#pragma config JTAGEN = OFF             // JTAG Enable bit (JTAG is disabled)

// FPOR
#pragma config ALTI2C1 = OFF            // Alternate I2C1 pins (I2C1 mapped to SDA1/SCL1 pins)
#pragma config ALTI2C2 = OFF            // Alternate I2C2 pins (I2C2 mapped to SDA2/SCL2 pins)
#pragma config WDTWIN = WIN25           // Watchdog Window Select bits (WDT Window is 25% of WDT period)

// FWDT
#pragma config WDTPOST = PS32768        // Watchdog Timer Postscaler bits (1:32,768)
#pragma config WDTPRE = PR128           // Watchdog Timer Prescaler bit (1:128)
#pragma config PLLKEN = ON              // PLL Lock Enable bit (Clock switch to PLL source will wait until the PLL lock signal is valid.)
#pragma config WINDIS = OFF             // Watchdog Timer Window Enable bit (Watchdog Timer in Non-Window mode)
#pragma config FWDTEN = OFF             // Watchdog Timer Enable bit (Watchdog timer enabled/disabled by user software)

// FOSC
#pragma config POSCMD = XT              // Primary Oscillator Mode Select bits (XT Crystal Oscillator Mode)
#pragma config OSCIOFNC = OFF           // OSC2 Pin Function bit (OSC2 is clock output)
#pragma config IOL1WAY = ON             // Peripheral pin select configuration (Allow only one reconfiguration)
#pragma config FCKSM = CSECMD           // Clock Switching Mode bits (Clock switching is enabled,Fail-safe Clock Monitor is disabled)

// FOSCSEL
#pragma config FNOSC = PRIPLL           // Oscillator Source Selection (Primary Oscillator with PLL module (XT + PLL, HS + PLL, EC + PLL))
#pragma config IESO = OFF               // Two-speed Oscillator Start-up Enable bit (Start up with user-selected oscillator source)

// FGS
#pragma config GWRP = OFF               // General Segment Write-Protect bit (General Segment may be written)
#pragma config GCP = OFF                // General Segment Code-Protect bit (General Segment Code protect is Disabled)

// #pragma config statements should precede project file includes.
// Use project enums instead of #define for ON and OFF.

#include <xc.h>
#include "wave_interface.h"
#include "sram_interface.h"
#include "block_len_def.h"
#include "stereo_chorus.h"
#include "stereo_delay.h"
#include "stereo_distortion.h"
#include "tone_control_2band.h"
#include "synth_types.h"

#include "voice.h"

////////////////////////////////////////////////////////////////////////////////
// Initialize system clock
////////////////////////////////////////////////////////////////////////////////
static void configureClock(void)
{
    // Configure PLL prescaler, PLL postscaler, PLL divisor
    // FCY = FOSC * M / (N1 * N2 * 2) = 10 MHz * 56 / (2 * 2 * 2) = 70 MHz
    PLLFBD = 54; // M = 56
    CLKDIVbits.PLLPOST = 0; // N2 = 2
    CLKDIVbits.PLLPRE = 0; // N1 = 2

    // Initiate Clock Switch to Primary Oscillator with PLL (NOSC=0b011)
    __builtin_write_OSCCONH(0x03);
    __builtin_write_OSCCONL(OSCCON | 0x01);

    // Wait for Clock switch to occur
    while (OSCCONbits.COSC != 0b011);

    // Wait for PLL to lock
    while (OSCCONbits.LOCK != 1);
}

////////////////////////////////////////////////////////////////////////////////
// Pin programming
////////////////////////////////////////////////////////////////////////////////
static void configurePins(void)
{
    // Unlock PPS
    __builtin_write_OSCCONL(OSCCON & ~(1 << 6));

    ////////////////////////////////////////////////////////////////////////////
    // SPI1 is configured as master with two /SS pins for external SRAM control

    // SCK1 -> Pin 16 - RB7
    TRISBbits.TRISB7 = 0;
    LATBbits.LATB7 = 0;

    // SDO1 -> Pin 17 - RB8
    TRISBbits.TRISB8 = 0;
    LATBbits.LATB8 = 0;

    // SDI1 -> Pin 18 - RB9
    TRISBbits.TRISB9 = 1;
    PORTBbits.RB9 = 0;

    // /SS10 -> Pin 15 - RB6
    TRISBbits.TRISB6 = 0;
    LATBbits.LATB6 = 1;

    // /SS11 -> Pin 22 - RB11
    TRISBbits.TRISB11 = 0;
    LATBbits.LATB11 = 1;

    ////////////////////////////////////////////////////////////////////////////
    // SPI2 is configured as slave

    // /SS2 --> Pin 23 - RB12 / RPI44 (input)
    TRISBbits.TRISB12 = 1;
    RPINR23bits.SS2R = 44;
 
    // SDI2 --> Pin 24 - RB13 / RPI45 (input)
    TRISBbits.TRISB13 = 1;
    RPINR22bits.SDI2R = 45;
 
    // SDO2 --> Pin 25 - RB14 / RPI46 (output) WIRING ERROR
    TRISBbits.TRISB14 = 1;
 
    // SDO2 --> Pin 21 - RB10 / RP42 (output)
    TRISBbits.TRISB10 = 0;
    LATBbits.LATB10 = 0;
    RPOR4bits.RP42R = 0b001000; // SDO2

    // SCK2 --> Pin 26 - RB15 / RPI47 (input)
    TRISBbits.TRISB15 = 1;
    RPINR22bits.SCK2R = 47;

    // Lock PPS
    __builtin_write_OSCCONL(OSCCON | (1 << 6));
}

////////////////////////////////////////////////////////////////////////////////
// Main loop
////////////////////////////////////////////////////////////////////////////////
int main(void)
{
    // Initialize hardware
    configureClock();
    configurePins();
    configureWaveInterface();
    configureSRAMInterface();

    // Voice states
    VoiceState voiceState[NOF_VOICES_DSP];
    
    // Tone control state
    ToneControl2BandState toneControlState;
    StereoDelayState delayState = {.writePos = 0, .readPos = 0, .filterStateLeft = {.stateValue = 0, .stateScaling = 0}, .filterStateRight = {.stateValue = 0, .stateScaling = 0}};

    // Initialize synth state
    for (uint8_t cntVoice = 0; cntVoice < NOF_VOICES_DSP; ++cntVoice)
    {
        initVoice(&voiceState[cntVoice]);
    }

    // Work buffers
    static _Q15 xBuffer[BLOCK_LEN] __attribute__((space(xmemory), far));
    static _Q15 yBuffer[6] __attribute__((space(ymemory), far));

    
    // Main loop:
    // Step 1: Calculate waveform for each voice according to voice parameters
    //         and current voice state
    // Step 2: Accumulate all voices into one waveform
    // Step 3: Wait for current waveform transfer to audio/fx DSP to complete
    // Step 4: Initiate next waveform transfer to audio/fx DSP
    while (1)
    {
        // Calculate and Update all voices
        DSPBuffer waveBufferVoice[NOF_VOICES_DSP];
        
        for (uint8_t cntVoice = 0; cntVoice < NOF_VOICES_DSP; ++cntVoice)
        {
            // Calc waveform data
            calcVoice(
                    getPatchParams(),
                    getVoiceParams(cntVoice),
                    &voiceState[cntVoice],
                    xBuffer,
                    yBuffer,
                    &waveBufferVoice[cntVoice]);
        }
        
        // Accumulate all voices
        DSPBuffer waveBufferAcc;
        for (uint8_t cntSample = 0; cntSample < BLOCK_LEN * 2; ++cntSample)
        {
            // Use the accumulator register to accumulate all voices into one wave buffer and get implicit single-cycle saturation of the sum
            // Prefer built-in functions over inline asm here - Compiler will unroll the for-loop across all voices
            // Hardware for-loop across all samples has to be sacrificed, though.
            
            // Load sample of first voice into accumulator
            volatile register int acc asm("A");
            acc = __builtin_lac(waveBufferVoice[0].buffer[cntSample], 0);

            // The iteration count of this for-loop is compile-time constant, so the compiler can unroll the loop (and does for nummber of voices = 4)
            for (uint8_t cntVoice = 1; cntVoice < NOF_VOICES_DSP; ++cntVoice)
            {
                // Add sample of remaining voices
                acc = __builtin_add(acc, waveBufferVoice[cntVoice].buffer[cntSample], 0);
            }

            // Clip sum of samples to int16 and write to output buffer
            waveBufferAcc.buffer[cntSample] = __builtin_sacr(acc, 0);
        }

        // Distortion
        addStereoDistortion(
                &getPatchParams()->distortionParams,
                waveBufferAcc.buffer);

        // Tone control
        calcToneControl2Band(
                &getPatchParams()->toneControlParams,
                &toneControlState,
                xBuffer,
                yBuffer,
                waveBufferAcc.bufferLeft,
                waveBufferAcc.bufferRight);
        
        // Delay
        waitSRAMTransfer();
        
        // Update delay line read and write position
        // NB. readPos and writePos are considered circular buffer indices and are intended to roll over at 65535
        delayState.readPos = (delayState.writePos += BLOCK_LEN) - getPatchParams()->delayParams.time;

        addStereoDelay(
                &getPatchParams()->delayParams,
                &delayState,
                getSRAM0Buffer(),
                getSRAM1Buffer(),
                waveBufferAcc.bufferLeft,
                waveBufferAcc.bufferRight);
        
        // Chorus
        addStereoChorus(
                &getPatchParams()->chorusParams,
                waveBufferAcc.bufferLeft,
                waveBufferAcc.bufferRight);
        
        // Bitcrusher
        

        // Transmit new waveform data
        transferWaveBuffer(waveBufferAcc.buffer);
        
        // Start SRAM transfer after wave buffer transfer to avoid audible glitches (caused by DMA stalls???)
        startSRAMTransfer(
                delayState.writePos,
                delayState.readPos);

    }

    return 0;
}